// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/m_app/internal/domain/model"
)

func newCommunityInterest(db *gorm.DB, opts ...gen.DOOption) communityInterest {
	_communityInterest := communityInterest{}

	_communityInterest.communityInterestDo.UseDB(db, opts...)
	_communityInterest.communityInterestDo.UseModel(&model.CommunityInterest{})

	tableName := _communityInterest.communityInterestDo.TableName()
	_communityInterest.ALL = field.NewAsterisk(tableName)
	_communityInterest.CommunityID = field.NewString(tableName, "community_id")
	_communityInterest.InterestID = field.NewInt32(tableName, "interest_id")
	_communityInterest.CreatedAt = field.NewTime(tableName, "created_at")

	_communityInterest.fillFieldMap()

	return _communityInterest
}

type communityInterest struct {
	communityInterestDo

	ALL         field.Asterisk
	CommunityID field.String
	InterestID  field.Int32
	CreatedAt   field.Time

	fieldMap map[string]field.Expr
}

func (c communityInterest) Table(newTableName string) *communityInterest {
	c.communityInterestDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c communityInterest) As(alias string) *communityInterest {
	c.communityInterestDo.DO = *(c.communityInterestDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *communityInterest) updateTableName(table string) *communityInterest {
	c.ALL = field.NewAsterisk(table)
	c.CommunityID = field.NewString(table, "community_id")
	c.InterestID = field.NewInt32(table, "interest_id")
	c.CreatedAt = field.NewTime(table, "created_at")

	c.fillFieldMap()

	return c
}

func (c *communityInterest) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *communityInterest) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 3)
	c.fieldMap["community_id"] = c.CommunityID
	c.fieldMap["interest_id"] = c.InterestID
	c.fieldMap["created_at"] = c.CreatedAt
}

func (c communityInterest) clone(db *gorm.DB) communityInterest {
	c.communityInterestDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c communityInterest) replaceDB(db *gorm.DB) communityInterest {
	c.communityInterestDo.ReplaceDB(db)
	return c
}

type communityInterestDo struct{ gen.DO }

type ICommunityInterestDo interface {
	gen.SubQuery
	Debug() ICommunityInterestDo
	WithContext(ctx context.Context) ICommunityInterestDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICommunityInterestDo
	WriteDB() ICommunityInterestDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICommunityInterestDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICommunityInterestDo
	Not(conds ...gen.Condition) ICommunityInterestDo
	Or(conds ...gen.Condition) ICommunityInterestDo
	Select(conds ...field.Expr) ICommunityInterestDo
	Where(conds ...gen.Condition) ICommunityInterestDo
	Order(conds ...field.Expr) ICommunityInterestDo
	Distinct(cols ...field.Expr) ICommunityInterestDo
	Omit(cols ...field.Expr) ICommunityInterestDo
	Join(table schema.Tabler, on ...field.Expr) ICommunityInterestDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICommunityInterestDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICommunityInterestDo
	Group(cols ...field.Expr) ICommunityInterestDo
	Having(conds ...gen.Condition) ICommunityInterestDo
	Limit(limit int) ICommunityInterestDo
	Offset(offset int) ICommunityInterestDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICommunityInterestDo
	Unscoped() ICommunityInterestDo
	Create(values ...*model.CommunityInterest) error
	CreateInBatches(values []*model.CommunityInterest, batchSize int) error
	Save(values ...*model.CommunityInterest) error
	First() (*model.CommunityInterest, error)
	Take() (*model.CommunityInterest, error)
	Last() (*model.CommunityInterest, error)
	Find() ([]*model.CommunityInterest, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommunityInterest, err error)
	FindInBatches(result *[]*model.CommunityInterest, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CommunityInterest) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICommunityInterestDo
	Assign(attrs ...field.AssignExpr) ICommunityInterestDo
	Joins(fields ...field.RelationField) ICommunityInterestDo
	Preload(fields ...field.RelationField) ICommunityInterestDo
	FirstOrInit() (*model.CommunityInterest, error)
	FirstOrCreate() (*model.CommunityInterest, error)
	FindByPage(offset int, limit int) (result []*model.CommunityInterest, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICommunityInterestDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c communityInterestDo) Debug() ICommunityInterestDo {
	return c.withDO(c.DO.Debug())
}

func (c communityInterestDo) WithContext(ctx context.Context) ICommunityInterestDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c communityInterestDo) ReadDB() ICommunityInterestDo {
	return c.Clauses(dbresolver.Read)
}

func (c communityInterestDo) WriteDB() ICommunityInterestDo {
	return c.Clauses(dbresolver.Write)
}

func (c communityInterestDo) Session(config *gorm.Session) ICommunityInterestDo {
	return c.withDO(c.DO.Session(config))
}

func (c communityInterestDo) Clauses(conds ...clause.Expression) ICommunityInterestDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c communityInterestDo) Returning(value interface{}, columns ...string) ICommunityInterestDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c communityInterestDo) Not(conds ...gen.Condition) ICommunityInterestDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c communityInterestDo) Or(conds ...gen.Condition) ICommunityInterestDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c communityInterestDo) Select(conds ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c communityInterestDo) Where(conds ...gen.Condition) ICommunityInterestDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c communityInterestDo) Order(conds ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c communityInterestDo) Distinct(cols ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c communityInterestDo) Omit(cols ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c communityInterestDo) Join(table schema.Tabler, on ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c communityInterestDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c communityInterestDo) RightJoin(table schema.Tabler, on ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c communityInterestDo) Group(cols ...field.Expr) ICommunityInterestDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c communityInterestDo) Having(conds ...gen.Condition) ICommunityInterestDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c communityInterestDo) Limit(limit int) ICommunityInterestDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c communityInterestDo) Offset(offset int) ICommunityInterestDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c communityInterestDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICommunityInterestDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c communityInterestDo) Unscoped() ICommunityInterestDo {
	return c.withDO(c.DO.Unscoped())
}

func (c communityInterestDo) Create(values ...*model.CommunityInterest) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c communityInterestDo) CreateInBatches(values []*model.CommunityInterest, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c communityInterestDo) Save(values ...*model.CommunityInterest) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c communityInterestDo) First() (*model.CommunityInterest, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityInterest), nil
	}
}

func (c communityInterestDo) Take() (*model.CommunityInterest, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityInterest), nil
	}
}

func (c communityInterestDo) Last() (*model.CommunityInterest, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityInterest), nil
	}
}

func (c communityInterestDo) Find() ([]*model.CommunityInterest, error) {
	result, err := c.DO.Find()
	return result.([]*model.CommunityInterest), err
}

func (c communityInterestDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommunityInterest, err error) {
	buf := make([]*model.CommunityInterest, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c communityInterestDo) FindInBatches(result *[]*model.CommunityInterest, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c communityInterestDo) Attrs(attrs ...field.AssignExpr) ICommunityInterestDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c communityInterestDo) Assign(attrs ...field.AssignExpr) ICommunityInterestDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c communityInterestDo) Joins(fields ...field.RelationField) ICommunityInterestDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c communityInterestDo) Preload(fields ...field.RelationField) ICommunityInterestDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c communityInterestDo) FirstOrInit() (*model.CommunityInterest, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityInterest), nil
	}
}

func (c communityInterestDo) FirstOrCreate() (*model.CommunityInterest, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityInterest), nil
	}
}

func (c communityInterestDo) FindByPage(offset int, limit int) (result []*model.CommunityInterest, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c communityInterestDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c communityInterestDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c communityInterestDo) Delete(models ...*model.CommunityInterest) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *communityInterestDo) withDO(do gen.Dao) *communityInterestDo {
	c.DO = *do.(*gen.DO)
	return c
}
