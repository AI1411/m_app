// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/m_app/internal/domain/model"
)

func newCommunityPostComment(db *gorm.DB, opts ...gen.DOOption) communityPostComment {
	_communityPostComment := communityPostComment{}

	_communityPostComment.communityPostCommentDo.UseDB(db, opts...)
	_communityPostComment.communityPostCommentDo.UseModel(&model.CommunityPostComment{})

	tableName := _communityPostComment.communityPostCommentDo.TableName()
	_communityPostComment.ALL = field.NewAsterisk(tableName)
	_communityPostComment.ID = field.NewString(tableName, "id")
	_communityPostComment.PostID = field.NewString(tableName, "post_id")
	_communityPostComment.UserID = field.NewString(tableName, "user_id")
	_communityPostComment.ParentID = field.NewString(tableName, "parent_id")
	_communityPostComment.Content = field.NewString(tableName, "content")
	_communityPostComment.MediaUrls = field.NewString(tableName, "media_urls")
	_communityPostComment.LikeCount = field.NewInt32(tableName, "like_count")
	_communityPostComment.IsApproved = field.NewBool(tableName, "is_approved")
	_communityPostComment.CreatedAt = field.NewTime(tableName, "created_at")
	_communityPostComment.UpdatedAt = field.NewTime(tableName, "updated_at")
	_communityPostComment.DeletedAt = field.NewField(tableName, "deleted_at")

	_communityPostComment.fillFieldMap()

	return _communityPostComment
}

type communityPostComment struct {
	communityPostCommentDo

	ALL        field.Asterisk
	ID         field.String // コメントID
	PostID     field.String // 投稿ID
	UserID     field.String // コメント投稿者のユーザーID
	ParentID   field.String // 親コメントID（返信の場合）
	Content    field.String // コメント内容
	MediaUrls  field.String // 添付メディアのURL配列
	LikeCount  field.Int32  // いいね数（キャッシュ）
	IsApproved field.Bool   // 承認済みフラグ（モデレーション用）
	CreatedAt  field.Time   // コメント作成日時
	UpdatedAt  field.Time   // コメント更新日時
	DeletedAt  field.Field  // 論理削除日時

	fieldMap map[string]field.Expr
}

func (c communityPostComment) Table(newTableName string) *communityPostComment {
	c.communityPostCommentDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c communityPostComment) As(alias string) *communityPostComment {
	c.communityPostCommentDo.DO = *(c.communityPostCommentDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *communityPostComment) updateTableName(table string) *communityPostComment {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewString(table, "id")
	c.PostID = field.NewString(table, "post_id")
	c.UserID = field.NewString(table, "user_id")
	c.ParentID = field.NewString(table, "parent_id")
	c.Content = field.NewString(table, "content")
	c.MediaUrls = field.NewString(table, "media_urls")
	c.LikeCount = field.NewInt32(table, "like_count")
	c.IsApproved = field.NewBool(table, "is_approved")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewField(table, "deleted_at")

	c.fillFieldMap()

	return c
}

func (c *communityPostComment) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *communityPostComment) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 11)
	c.fieldMap["id"] = c.ID
	c.fieldMap["post_id"] = c.PostID
	c.fieldMap["user_id"] = c.UserID
	c.fieldMap["parent_id"] = c.ParentID
	c.fieldMap["content"] = c.Content
	c.fieldMap["media_urls"] = c.MediaUrls
	c.fieldMap["like_count"] = c.LikeCount
	c.fieldMap["is_approved"] = c.IsApproved
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
}

func (c communityPostComment) clone(db *gorm.DB) communityPostComment {
	c.communityPostCommentDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c communityPostComment) replaceDB(db *gorm.DB) communityPostComment {
	c.communityPostCommentDo.ReplaceDB(db)
	return c
}

type communityPostCommentDo struct{ gen.DO }

type ICommunityPostCommentDo interface {
	gen.SubQuery
	Debug() ICommunityPostCommentDo
	WithContext(ctx context.Context) ICommunityPostCommentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICommunityPostCommentDo
	WriteDB() ICommunityPostCommentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICommunityPostCommentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICommunityPostCommentDo
	Not(conds ...gen.Condition) ICommunityPostCommentDo
	Or(conds ...gen.Condition) ICommunityPostCommentDo
	Select(conds ...field.Expr) ICommunityPostCommentDo
	Where(conds ...gen.Condition) ICommunityPostCommentDo
	Order(conds ...field.Expr) ICommunityPostCommentDo
	Distinct(cols ...field.Expr) ICommunityPostCommentDo
	Omit(cols ...field.Expr) ICommunityPostCommentDo
	Join(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo
	Group(cols ...field.Expr) ICommunityPostCommentDo
	Having(conds ...gen.Condition) ICommunityPostCommentDo
	Limit(limit int) ICommunityPostCommentDo
	Offset(offset int) ICommunityPostCommentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICommunityPostCommentDo
	Unscoped() ICommunityPostCommentDo
	Create(values ...*model.CommunityPostComment) error
	CreateInBatches(values []*model.CommunityPostComment, batchSize int) error
	Save(values ...*model.CommunityPostComment) error
	First() (*model.CommunityPostComment, error)
	Take() (*model.CommunityPostComment, error)
	Last() (*model.CommunityPostComment, error)
	Find() ([]*model.CommunityPostComment, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommunityPostComment, err error)
	FindInBatches(result *[]*model.CommunityPostComment, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CommunityPostComment) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICommunityPostCommentDo
	Assign(attrs ...field.AssignExpr) ICommunityPostCommentDo
	Joins(fields ...field.RelationField) ICommunityPostCommentDo
	Preload(fields ...field.RelationField) ICommunityPostCommentDo
	FirstOrInit() (*model.CommunityPostComment, error)
	FirstOrCreate() (*model.CommunityPostComment, error)
	FindByPage(offset int, limit int) (result []*model.CommunityPostComment, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICommunityPostCommentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c communityPostCommentDo) Debug() ICommunityPostCommentDo {
	return c.withDO(c.DO.Debug())
}

func (c communityPostCommentDo) WithContext(ctx context.Context) ICommunityPostCommentDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c communityPostCommentDo) ReadDB() ICommunityPostCommentDo {
	return c.Clauses(dbresolver.Read)
}

func (c communityPostCommentDo) WriteDB() ICommunityPostCommentDo {
	return c.Clauses(dbresolver.Write)
}

func (c communityPostCommentDo) Session(config *gorm.Session) ICommunityPostCommentDo {
	return c.withDO(c.DO.Session(config))
}

func (c communityPostCommentDo) Clauses(conds ...clause.Expression) ICommunityPostCommentDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c communityPostCommentDo) Returning(value interface{}, columns ...string) ICommunityPostCommentDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c communityPostCommentDo) Not(conds ...gen.Condition) ICommunityPostCommentDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c communityPostCommentDo) Or(conds ...gen.Condition) ICommunityPostCommentDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c communityPostCommentDo) Select(conds ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c communityPostCommentDo) Where(conds ...gen.Condition) ICommunityPostCommentDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c communityPostCommentDo) Order(conds ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c communityPostCommentDo) Distinct(cols ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c communityPostCommentDo) Omit(cols ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c communityPostCommentDo) Join(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c communityPostCommentDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c communityPostCommentDo) RightJoin(table schema.Tabler, on ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c communityPostCommentDo) Group(cols ...field.Expr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c communityPostCommentDo) Having(conds ...gen.Condition) ICommunityPostCommentDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c communityPostCommentDo) Limit(limit int) ICommunityPostCommentDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c communityPostCommentDo) Offset(offset int) ICommunityPostCommentDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c communityPostCommentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICommunityPostCommentDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c communityPostCommentDo) Unscoped() ICommunityPostCommentDo {
	return c.withDO(c.DO.Unscoped())
}

func (c communityPostCommentDo) Create(values ...*model.CommunityPostComment) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c communityPostCommentDo) CreateInBatches(values []*model.CommunityPostComment, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c communityPostCommentDo) Save(values ...*model.CommunityPostComment) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c communityPostCommentDo) First() (*model.CommunityPostComment, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityPostComment), nil
	}
}

func (c communityPostCommentDo) Take() (*model.CommunityPostComment, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityPostComment), nil
	}
}

func (c communityPostCommentDo) Last() (*model.CommunityPostComment, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityPostComment), nil
	}
}

func (c communityPostCommentDo) Find() ([]*model.CommunityPostComment, error) {
	result, err := c.DO.Find()
	return result.([]*model.CommunityPostComment), err
}

func (c communityPostCommentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommunityPostComment, err error) {
	buf := make([]*model.CommunityPostComment, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c communityPostCommentDo) FindInBatches(result *[]*model.CommunityPostComment, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c communityPostCommentDo) Attrs(attrs ...field.AssignExpr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c communityPostCommentDo) Assign(attrs ...field.AssignExpr) ICommunityPostCommentDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c communityPostCommentDo) Joins(fields ...field.RelationField) ICommunityPostCommentDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c communityPostCommentDo) Preload(fields ...field.RelationField) ICommunityPostCommentDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c communityPostCommentDo) FirstOrInit() (*model.CommunityPostComment, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityPostComment), nil
	}
}

func (c communityPostCommentDo) FirstOrCreate() (*model.CommunityPostComment, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CommunityPostComment), nil
	}
}

func (c communityPostCommentDo) FindByPage(offset int, limit int) (result []*model.CommunityPostComment, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c communityPostCommentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c communityPostCommentDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c communityPostCommentDo) Delete(models ...*model.CommunityPostComment) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *communityPostCommentDo) withDO(do gen.Dao) *communityPostCommentDo {
	c.DO = *do.(*gen.DO)
	return c
}
